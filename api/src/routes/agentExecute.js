// AGO Agent Execution Engine — /api/agents/execute
// Auto-generated by Script 22 — DO NOT hand edit
// Governed dispatch: policy check → route to GCP → wrap result → audit

const express = require('express');
const router  = express.Router();

const gcpBankClient       = require('../integrations/gcpBankClient');
const healthNetworkClient = require('../integrations/healthNetworkClient');
const retailGroupClient   = require('../integrations/retailGroupClient');
const legalPartnersClient = require('../integrations/legalPartnersClient');

// Client registry — maps clientId to HTTP client
const CLIENT_REGISTRY = {
  bank:   { client: gcpBankClient,       name: 'First National Virtual Bank',    apiKey: 'chc-bank-dev-key-2026'   },
  health: { client: healthNetworkClient, name: 'Cascade Regional Health Network', apiKey: 'chc-health-dev-key-2026' },
  retail: { client: retailGroupClient,   name: 'Summit Retail Group',             apiKey: 'chc-retail-dev-key-2026' },
  legal:  { client: legalPartnersClient, name: 'Meridian Legal Partners LLP',     apiKey: 'chc-legal-dev-key-2026'  }
};

// In-memory execution log (last 1000 executions)
const EXECUTION_LOG = [];

// ── Sentinel policy checks ────────────────────────────────────
const RATE_WINDOWS = {};
function rateLimitCheck(clientId, agentId) {
  const key = clientId + ':' + agentId;
  const now = Date.now();
  if (!RATE_WINDOWS[key]) RATE_WINDOWS[key] = [];
  RATE_WINDOWS[key] = RATE_WINDOWS[key].filter(t => now - t < 60000);
  if (RATE_WINDOWS[key].length >= 100) return { passed: false, reason: 'Rate limit exceeded (100/min)' };
  RATE_WINDOWS[key].push(now);
  return { passed: true };
}

function policyChecks(clientId, agentId, task) {
  const checks = [];
  const rl = rateLimitCheck(clientId, agentId);
  checks.push({ check: 'rate_limit',        passed: rl.passed,  reason: rl.reason || null });
  checks.push({ check: 'client_registered', passed: !!CLIENT_REGISTRY[clientId], reason: !CLIENT_REGISTRY[clientId] ? 'Unknown client' : null });
  checks.push({ check: 'request_schema',    passed: !!(clientId && agentId && task), reason: (!clientId || !agentId || !task) ? 'Missing required fields' : null });
  checks.push({ check: 'output_validation', passed: true, reason: null });
  const failed = checks.filter(c => !c.passed);
  return { passed: failed.length === 0, checks, failed };
}

// ── Direct GCP execution call ─────────────────────────────────
async function executeOnGCP(clientId, agentId, task, payload, governanceToken) {
  const { client, apiKey } = CLIENT_REGISTRY[clientId];
  const url = client.config?.baseUrl || '';

  const https = require('https');
  return new Promise((resolve, reject) => {
    const body = JSON.stringify({ task, payload: payload || {}, governanceToken, requestId: 'ago-' + Date.now() });
    const u = new URL(url + '/api/agents/' + agentId + '/execute');
    const req = https.request({
      hostname: u.hostname, path: u.pathname,
      method: 'POST',
      headers: { 'x-api-key': apiKey, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(body) }
    }, (res) => {
      let data = '';
      res.on('data', c => data += c);
      res.on('end', () => {
        try { resolve({ status: res.statusCode, ok: res.statusCode < 300, data: JSON.parse(data) }); }
        catch(e) { resolve({ status: res.statusCode, ok: false, data: { error: data } }); }
      });
    });
    req.on('error', reject);
    req.setTimeout(15000, () => { req.destroy(); reject(new Error('GCP execution timeout')); });
    req.write(body);
    req.end();
  });
}

// ── POST /api/agents/execute ──────────────────────────────────
router.post('/', async (req, res) => {
  const startMs = Date.now();
  const { clientId, agentId, task, payload } = req.body;

  // Sentinel policy gate
  const policy = policyChecks(clientId, agentId, task);
  if (!policy.passed) {
    return res.status(400).json({
      success: false,
      governed: true,
      policyBlocked: true,
      failedChecks: policy.failed,
      message: policy.failed[0]?.reason || 'Policy check failed'
    });
  }

  const governanceToken = 'gov-' + Date.now() + '-' + Math.random().toString(36).substr(2, 8);

  try {
    const gcpResult = await executeOnGCP(clientId, agentId, task, payload, governanceToken);

    if (!gcpResult.ok) {
      return res.status(502).json({ success: false, error: 'GCP execution failed', details: gcpResult.data });
    }

    const execution = gcpResult.data.data;
    const governed = {
      executionId:     execution.executionId,
      governanceToken,
      clientId,
      clientName:      CLIENT_REGISTRY[clientId].name,
      agentId,
      agentName:       execution.agentName,
      task,
      governed:        true,
      policyChecks:    policy.checks,
      governanceScore: execution.governanceScore,
      result:          execution.result,
      complianceStatus:'PASSED',
      auditTrail:      true,
      totalLatencyMs:  Date.now() - startMs,
      gcpLatencyMs:    execution.latencyMs,
      agoLatencyMs:    (Date.now() - startMs) - (execution.latencyMs || 0),
      executedAt:      new Date().toISOString()
    };

    EXECUTION_LOG.push(governed);
    if (EXECUTION_LOG.length > 1000) EXECUTION_LOG.shift();

    res.json({ success: true, data: governed });

  } catch(err) {
    res.status(502).json({ success: false, error: err.message });
  }
});

// ── GET /api/agents/executions — recent log ───────────────────
router.get('/executions', (req, res) => {
  const limit  = parseInt(req.query.limit) || 50;
  const client = req.query.clientId;
  const log    = client
    ? EXECUTION_LOG.filter(e => e.clientId === client)
    : EXECUTION_LOG;
  res.json({
    success: true,
    total:   EXECUTION_LOG.length,
    count:   Math.min(limit, log.length),
    data:    log.slice(-limit).reverse()
  });
});

// ── GET /api/agents/stats ─────────────────────────────────────
router.get('/stats', (req, res) => {
  const byClient = {};
  for (const e of EXECUTION_LOG) {
    if (!byClient[e.clientId]) byClient[e.clientId] = { count: 0, avgScore: 0, scores: [] };
    byClient[e.clientId].count++;
    byClient[e.clientId].scores.push(e.governanceScore);
  }
  for (const c of Object.values(byClient)) {
    c.avgScore = c.scores.length ? Math.round(c.scores.reduce((a,b) => a+b) / c.scores.length) : 0;
    delete c.scores;
  }
  res.json({
    success: true,
    totalExecutions: EXECUTION_LOG.length,
    byClient,
    avgGovernanceScore: EXECUTION_LOG.length
      ? Math.round(EXECUTION_LOG.reduce((s,e) => s + (e.governanceScore||0), 0) / EXECUTION_LOG.length)
      : 0
  });
});

module.exports = router;
module.exports.EXECUTION_LOG = EXECUTION_LOG;
