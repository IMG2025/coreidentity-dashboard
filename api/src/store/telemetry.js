// Telemetry Store — shared in-memory ring buffer
// Auto-generated by Script 23 — DO NOT hand edit

const MAX_ENTRIES = 2000;

const store = {
  executions: [],   // all governed executions (AWS AGO + GCP ingest)
  syncs:      [],   // telemetry sync events
  stats: {
    totalExecutions:    0,
    totalSyncs:         0,
    avgGovernanceScore: 0,
    byClient:           {},
    lastUpdated:        null
  }
};

function addExecution(entry) {
  store.executions.push({ ...entry, storedAt: new Date().toISOString() });
  if (store.executions.length > MAX_ENTRIES) store.executions.shift();
  rebuildStats();
}

function addSync(entry) {
  store.syncs.push({ ...entry, storedAt: new Date().toISOString() });
  if (store.syncs.length > 500) store.syncs.shift();
  store.stats.totalSyncs++;
  store.stats.lastUpdated = new Date().toISOString();
}

function rebuildStats() {
  store.stats.totalExecutions = store.executions.length;
  const byClient = {};
  let scoreSum = 0, scoreCount = 0;
  for (const e of store.executions) {
    const cid = e.clientId || e.source || 'unknown';
    if (!byClient[cid]) byClient[cid] = { count: 0, avgScore: 0, scores: [], lastExecution: null };
    byClient[cid].count++;
    byClient[cid].lastExecution = e.executedAt || e.storedAt;
    if (e.governanceScore) {
      byClient[cid].scores.push(e.governanceScore);
      scoreSum += e.governanceScore;
      scoreCount++;
    }
  }
  for (const c of Object.values(byClient)) {
    c.avgScore = c.scores.length ? Math.round(c.scores.reduce((a,b) => a+b) / c.scores.length) : 0;
    delete c.scores;
  }
  store.stats.byClient = byClient;
  store.stats.avgGovernanceScore = scoreCount ? Math.round(scoreSum / scoreCount) : 0;
  store.stats.lastUpdated = new Date().toISOString();
}

function getRecent(limit, clientId) {
  const src = clientId
    ? store.executions.filter(e => (e.clientId || e.source) === clientId)
    : store.executions;
  return src.slice(-limit).reverse();
}

module.exports = { addExecution, addSync, getRecent, store };
