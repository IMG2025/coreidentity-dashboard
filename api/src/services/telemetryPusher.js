// Telemetry Pusher — AWS AGO → GCP Corporate API
// Auto-generated by Script 23 — DO NOT hand edit
// Called after every governed execution in agentExecute.js

const https  = require('https');
const { addExecution, addSync } = require('../store/telemetry');

const CORP_URL = 'https://chc-corporate-api-lvuq2yqbma-uc.a.run.app';
const CORP_KEY = 'chc-corp-dev-key-2026';

// Push execution telemetry to GCP corporate API
async function pushToGCP(execution) {
  // Also store locally first — zero data loss if GCP unreachable
  addExecution({ ...execution, source: 'AWS_AGO' });

  const payload = JSON.stringify({
    source:     'AWS_AGO',
    executions: [execution],
    syncType:   'AGO_EXECUTION',
    timestamp:  new Date().toISOString()
  });

  return new Promise((resolve) => {
    const u = new URL(CORP_URL + '/api/governance/sync');
    const req = https.request({
      hostname: u.hostname,
      path:     u.pathname,
      method:   'POST',
      headers: {
        'x-api-key':      CORP_KEY,
        'Content-Type':   'application/json',
        'Content-Length': Buffer.byteLength(payload)
      }
    }, (res) => {
      let data = '';
      res.on('data', c => data += c);
      res.on('end', () => {
        try {
          const result = JSON.parse(data);
          addSync({ source: 'AWS_AGO', target: 'GCP_CORP', count: 1, syncId: result.syncId, success: true });
          resolve({ success: true, syncId: result.syncId });
        } catch(e) {
          resolve({ success: false, error: 'Parse error' });
        }
      });
    });
    req.on('error', (e) => resolve({ success: false, error: e.message }));
    req.setTimeout(5000, () => { req.destroy(); resolve({ success: false, error: 'Timeout' }); });
    req.write(payload);
    req.end();
  });
}

// Batch push — called on interval to sync recent executions
let lastBatchAt = Date.now();
const BATCH_QUEUE = [];

function queueForBatch(execution) {
  BATCH_QUEUE.push(execution);
}

async function flushBatch() {
  if (!BATCH_QUEUE.length) return;
  const batch = BATCH_QUEUE.splice(0, 50);
  const payload = JSON.stringify({
    source:     'AWS_AGO_BATCH',
    executions: batch,
    syncType:   'BATCH_FLUSH',
    timestamp:  new Date().toISOString()
  });
  return new Promise((resolve) => {
    const u = new URL(CORP_URL + '/api/governance/sync');
    const req = https.request({
      hostname: u.hostname, path: u.pathname, method: 'POST',
      headers: { 'x-api-key': CORP_KEY, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) }
    }, (res) => {
      res.on('data', () => {});
      res.on('end', () => { addSync({ source: 'AWS_AGO', target: 'GCP_CORP', count: batch.length, syncType: 'BATCH', success: true }); resolve(); });
    });
    req.on('error', resolve);
    req.setTimeout(5000, () => { req.destroy(); resolve(); });
    req.write(payload);
    req.end();
  });
}

// Auto-flush every 30 seconds
setInterval(flushBatch, 30000);

module.exports = { pushToGCP, queueForBatch, flushBatch };
